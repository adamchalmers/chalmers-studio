// Tops

import cross, dot, magnitude, normalize from "vectors.kcl"


topNone = 0
topCounterbore = 1
topCountersink = 2

conventionalPlane = XY

export fn noTopFeature() {
  return { feature = topNone }
}

export fn counterbore(diameter, depth) {
  return {
    diameter = diameter,
    depth = depth,
    feature = topCounterbore
  }
}

export fn countersink(diameter, angle) {
  return {
    diameter = diameter,
    angle = angle,
    feature = topCountersink
  }
}

// Bodies


export fn blind(depth, diameter) {
  return {
    blindDepth = depth,
    diameter = diameter
  }
}

// Ends


export fn drill(bitAngle) {
  return { drillBitAngle = bitAngle }
}

export fn flat() {
  return { drillBitAngle = 180deg }
}

// Defining the hole


fn drawTop(@partialHoleProfile, body, top) {
  return if top.feature == topNone {
    partialHoleProfile
      |> yLine(length = body.diameter)
  } else if top.feature == topCounterbore {
    lip = (top.diameter - body.diameter) / 2
    partialHoleProfile
      |> xLine(length = top.depth)
      |> yLine(length = top.diameter / 2)
      |> xLine(length = -top.depth)
      |> yLine(length = -lip)
  } else if top.feature == topCountersink {
    t = top.angle / 2
    // assert(t, isEqualTo = 15deg)
    tr = top.diameter / 2
    assert(tr, isGreaterThan = body.diameter / 2)
    // assert(tr, isEqualTo = 4)
    br = body.diameter / 2
    up = (tr - br) / tan(t)
    b = br / tan(t)
    p = (up + b) / cos(t) - (2 / (tan(t) * cos(t)))
    a = 90 - t
    partialHoleProfile
      |> xLine(length = up)
      |> yLine(length = tr)
      |> angledLine(length = p, angle = 270 - a)
  } else {
    assert(1, isEqualTo = 0, msg = "unknown top feature")
  }
}

export fn holeProfile(bottom, body, top) {
  radius = body.diameter / 2
  theta = bottom.drillBitAngle / 2

  adj = radius / tan(theta)
  hyp = radius / sin(theta)
  return startSketchOn(conventionalPlane)
    |> startProfile(at = [0, 0])
    // Drill profile
    |> xLine(length = adj)
    // Body depth
    |> xLine(length = body.blindDepth)
    // Dynamic dispatch to top
    |> drawTop(body, top)
    // Body depth
    |> xLine(length = -body.blindDepth)
    // // Drill profile
    |> line(endAbsolute = [profileStartX(%), profileStartY(%)])
    |> close()
}

// Actually defining a hole

export fn visualize(@holeProfile) {
  return holeProfile
    |> revolve(axis = X)
    |> appearance(color = "#ff0000")
}


export fn hole(@solid, face, hole) {
  targetPlane = planeOf(solid, face)
  targetPlaneNormal = cross(v1 = targetPlane.xAxis, v2 = targetPlane.yAxis)
  // v2 is the X axis by convention, but cannot coerce properly
  // so must give it manually.
  v2 = [1, 0, 0]
  tn = cross(v1 = v2, v2 = targetPlaneNormal)
  targetNormal = [
    tn[0]: number(mm),
    tn[1]: number(mm),
    tn[2]: number(mm)
  ]: Point3d
  dotProd = dot(v1 =   normalize(targetPlaneNormal), v2 =   normalize(v2)): number(_)
  rot = if magnitude(targetNormal) == 0 {
    if acos(dotProd) == 180deg {
      { axis = [0, 1, 0], angle = 180deg }
    } else {
      { axis = [1, 0, 0], angle = 0 }
    }
  } else {
    {
      axis = targetNormal,
      angle = acos(dotProd)
    }
  }
  toCut = hole
    |> visualize()
    |> rotate(axis = rot.axis, angle = rot.angle)
  return subtract(solid, tools = [toCut])
}

