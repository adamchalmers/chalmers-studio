// Tops


topNone = 0
topCounterbore = 1
topCountersink = 2

conventionalPlane = XY

export fn noTopFeature() {
  return { feature = topNone }
}

export fn counterbore(diameter, depth) {
  return {
    diameter = diameter,
    depth = depth,
    feature = topCounterbore
  }
}

export fn countersink(diameter, angle) {
  return {
    diameter = diameter,
    angle = angle,
    feature = topCountersink,
  }
}

// Bodies


export fn blind(depth, diameter) {
  return {
    blindDepth = depth,
    diameter = diameter
  }
}

// Ends


export fn drill(bitAngle) {
  return { drillBitAngle = bitAngle }
}

export fn flat() {
  return { drillBitAngle = 180deg }
}

// Defining the hole


fn drawTop(@partialHoleProfile, body, top) {
  return if top.feature == topNone {
  
    partialHoleProfile
      |> yLine(length = body.diameter)
      
  } else if top.feature == topCounterbore {
  
    lip = (top.diameter - body.diameter) / 2
    partialHoleProfile
      |> xLine(length = top.depth)
      |> yLine(length = top.diameter / 2)
      |> xLine(length = -top.depth)
      |> yLine(length = -lip)
      
  } else if top.feature == topCountersink {
  
    t = top.angle /2
    bigR = top.diameter/2
    smlR = body.diameter/2
    bigAdj = tan(t) / bigR
    bigH = bigR / sin(t)
    smlAdj = tan(t) / smlR
    smlH = smlR / sin(t)
    up = bigAdj - smlAdj
    partialHoleProfile
    |> xLine(length = up)
    |> yLine(length = bigR)
    |> angledLine(length = (bigH - smlH), angle = (90deg-t)+180)
    
  } else {
    assert(1, isEqualTo = 0, msg = "unknown top feature")
  }
}

export fn holeProfile(bottom, body, top) {
  radius = body.diameter / 2
  theta = bottom.drillBitAngle / 2

  adj = radius / tan(theta)
  hyp = radius / sin(theta)
  return startSketchOn(conventionalPlane)
    |> startProfile(at = [0, 0])
    // Drill profile
    |> xLine(length = adj)
    // Body depth
    |> xLine(length = body.blindDepth)
    // Dynamic dispatch to top
    |> drawTop(body, top)
     // Body depth
    |> xLine(length = -body.blindDepth)
    // // Drill profile
    |> line(endAbsolute = [profileStartX(%), profileStartY(%)])
    |> close()
}

// Geo math

fn cross(v1, v2) {
  return [
    v1[1] * v2[2] - (v1[2] * v2[1]),
    v1[2] * v2[0] - (v1[0] * v2[2]),
    v1[0] * v2[1] - (v1[1] * v2[0])
  ]
}

fn dot(v1, v2) {
  return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]
}

fn sub(@a, b) {
  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]
}

fn add(@a, b) {
  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]]
}

fn div(@v, s) {
  return [v[0] / s, v[1] / s, v[2] / s]
}

fn magnitude(@v) {
  return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])
}

fn normalize(@v) {
  len = magnitude(v)
  return [v[0] / len, v[1] / len, v[2] / len]
}

fn rot(@M, v) {
  return [
    M[0] * v[0] + M[1] * v[1] + M[2] * v[2],
    M[3] * v[0] + M[4] * v[1] + M[5] * v[2],
    M[6] * v[0] + M[7] * v[1] + M[8] * v[2]
  ]
}

fn angleAxis(angle, axis) {
  x = axis[0]
  y = axis[1]
  z = axis[2]
  x2 = axis[0] * axis[0]
  y2 = axis[1] * axis[1]
  z2 = axis[2] * axis[2]

  c = cos(angle)
  s = sin(angle)

  return [
    x2 * (1 - c) + c,
    x * y * (1 - c) - (z * s),
    x * z * (1 - c) + y * s,
    x * y * (1 - c) + z * s,
    y2 * (1 - c) + c,
    y * z * (1 - c) - (x * s),
    x * z * (1 - c) - (y * s),
    y * z * (1 - c) + x * s,
    z2 * (1 - c) + c
  ]
}

// Actually defining a hole


export fn carveHoleInto(@solid, face, hole) {
  targetPlane = planeOf(solid, face)
  targetPlaneNormal = cross(v1 = targetPlane.xAxis, v2 = targetPlane.yAxis)
  // v2 is the X axis by convention, but cannot coerce properly
  // so must give it manually.
  v2 = [1,0,0] 
  tn = cross(v1 = v2, v2 = targetPlaneNormal)
  targetNormal = [
    tn[0]: number(mm),
    tn[1]: number(mm),
    tn[2]: number(mm),
  ]: Point3d
  dotProd = dot(
    v1 = normalize(targetPlaneNormal),
    v2 = normalize(v2),
  ): number(_)
  rot = if (magnitude(targetNormal) == 0) {
    { axis = [1, 0, 0], angle = 0 } 
  } else {
    { axis = targetNormal, angle = acos(dotProd) }
  }
  toCut = hole
    |> revolve(axis = X)
    |> rotate(axis = rot.axis, angle = rot.angle)
    |> appearance(color = "#ff0000")
  // return subtract(solid, tools = [toCut])
  return 3
}

cubeLen = 10
bigCube = startSketchOn(XY) |> 
startProfile(at = [-cubeLen/2, -cubeLen/2])
|> line(end = [cubeLen, 0])
|> line(end = [0, cubeLen])
|> line(end = [-cubeLen, 0])
|> line(end = [0, -cubeLen], tag = $a)
|> close()
|> extrude(length = cubeLen, symmetric = true)

carveHoleInto(
  bigCube,
  face = a,
  hole = holeProfile(
    bottom = flat(),
    body = blind(depth = 10, diameter = 4),
    top = counterbore(diameter = 5, depth = 2),
  )
)