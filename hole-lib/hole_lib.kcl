// Tops


topNone = 0
topCounterbore = 1
topCountersink = 2

export fn noTopFeature() {
  return { feature = topNone }
}

export fn counterbore(diameter, depth) {
  return {
    diameter = diameter,
    depth = depth,
    feature = topCounterbore
  }
}

export fn countersink(diameter, angle) {
  return {
    diameter = diameter,
    angle = angle,
    feature = topCountersink,
  }
}

// Bodies


export fn blind(depth, diameter) {
  return {
    blindDepth = depth,
    diameter = diameter
  }
}

// Ends


export fn drill(bitAngle) {
  return { drillBitAngle = bitAngle }
}

export fn flat() {
  return { drillBitAngle = 180deg }
}

// Defining the hole


fn drawTop(@partialHoleProfile, body, top) {
  return if top.feature == topNone {
  
    partialHoleProfile
      |> yLine(length = body.diameter)
      
  } else if top.feature == topCounterbore {
  
    lip = (top.diameter - body.diameter) / 2
    partialHoleProfile
      |> xLine(length = top.depth)
      |> yLine(length = top.diameter / 2)
      |> xLine(length = -top.depth)
      |> yLine(length = -lip)
      
  } else if top.feature == topCountersink {
  
    t = top.angle /2
    bigR = top.diameter/2
    smlR = body.diameter/2
    bigAdj = tan(t) / bigR
    bigH = bigR / sin(t)
    smlAdj = tan(t) / smlR
    smlH = smlR / sin(t)
    up = bigAdj - smlAdj
    partialHoleProfile
    |> xLine(length = up)
    |> yLine(length = bigR)
    |> angledLine(length = (bigH - smlH), angle = (90deg-t)+180)
    
  } else {
    assert(1, isEqualTo = 0, msg = "unknown top feature")
  }
}

export fn holeProfile(bottom, body, top) {
  radius = body.diameter / 2
  theta = bottom.drillBitAngle / 2

  adj = radius / tan(theta)
  hyp = radius / sin(theta)
  return startSketchOn(XY)
    |> startProfile(at = [0, 0])
    // Drill profile
    |> xLine(length = adj)
    // Body depth
    |> xLine(length = body.blindDepth)
    // Dynamic dispatch to top
    |> drawTop(body, top)
     // Body depth
    |> xLine(length = -body.blindDepth)
    // // Drill profile
    |> line(endAbsolute = [profileStartX(%), profileStartY(%)])
    |> close()
}

// Actually defining a hole


export fn carveHole(@holeProfile) {
  return holeProfile
    |> revolve(axis = X)
    |> rotate(axis = Z, angle = 90deg)
}
